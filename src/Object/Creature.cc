// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
#include <Creature.h>
#include <algorithm>
#include <cmath>
#include <creature_export.h>  // Generated by Cmake
#include <functional>
#include <queue>
#include "../Map/Map.h"
#include "../Map/Space.h"
int32_t Creature::kCreatureSize = 0;
constexpr int32_t Creature::kMaxViewDis;
CREATURE_NO_EXPORT inline int64_t Square(const int32_t& in) {
  return static_cast< int64_t >(in)*static_cast< int64_t >(in);
}
// Both a and b should be positive
CREATURE_NO_EXPORT inline int32_t GetDifference(const int32_t& a,
                                                const int32_t& b) {
  if (a > b) return a - b;
  return b - a;
}
CREATURE_EXPORT Creature::CostOfBlock_ref Creature::CostOfBlock::Create() {
  return CostOfBlock_ref(new CostOfBlock());
}
CREATURE_EXPORT Creature::CostOfBlock& Creature::CostOfBlock::operator=(
    const Creature::CostOfBlock& a) {
  destory_ = a.destory_;
  move_ = a.move_;
  see_through_ = a.see_through_;
  return *this;
}
CREATURE_EXPORT void Creature::CostOfBlock::BindDestoryCost(
    const std::function< int32_t() >& function) {
  destory_ = function;
}
CREATURE_EXPORT void Creature::CostOfBlock::BindMoveCost(
    const std::function< int32_t() >& function) {
  move_ = function;
}
CREATURE_EXPORT void Creature::CostOfBlock::BindSeeThroughCost(
    const std::function< int32_t() >& function) {
  see_through_ = function;
}
CREATURE_NO_EXPORT int32_t Creature::CostOfBlock::DestoryCost() const {
  return destory_();
}
CREATURE_NO_EXPORT int32_t Creature::CostOfBlock::MoveCost() const {
  return move_();
}
CREATURE_NO_EXPORT int32_t Creature::CostOfBlock::SeeThroughCost() const {
  return see_through_();
}
CREATURE_EXPORT Creature::CostOfBlock::~CostOfBlock() {}
CREATURE_NO_EXPORT Creature::CostOfBlock::CostOfBlock() {}
CREATURE_EXPORT Creature_ref Creature::CreateCreature() {
  return Creature_ref(new Creature());
}
CREATURE_EXPORT Creature_ref Creature::CreateCreature(Space* const space) {
  return Creature_ref(new Creature(space));
}
CREATURE_EXPORT void Creature::set_now_map(Map* const map) {now_.map = map;}
CREATURE_EXPORT Map* Creature::now_map() const {return now_.map;}
CREATURE_EXPORT void Creature::set_now_position(const Point& position) {
  now_.position = position;
}
template <int32_t x, int32_t y>
CREATURE_NO_EXPORT void Creature::Move() {
  Point des = now_position();
  des.x += x;
  des.y += y;
  if (des.x < 0 || des.y < 0 ||
      des.x >= now_.map->Width() || des.y >= now_.map->Height()) return;
  const int32_t c_m = information_.cost[now_map()->Block(des)]->MoveCost();
  if (c_m < 0 || c_m > ability_.now_energy) return;
  ability_.now_energy -= c_m;
  set_now_position(des);
}
constexpr Point kWASD[4] = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};
//   W         UP
// A S D Left Down Right
template CREATURE_EXPORT void Creature::Move<kWASD[0].x, kWASD[0].y>();
template CREATURE_EXPORT void Creature::Move<kWASD[1].x, kWASD[1].y>();
template CREATURE_EXPORT void Creature::Move<kWASD[2].x, kWASD[2].y>();
template CREATURE_EXPORT void Creature::Move<kWASD[3].x, kWASD[3].y>();
CREATURE_EXPORT const Point& Creature::now_position() const {
  return now_.position;
}
CREATURE_EXPORT void Creature::set_now_space(Space* const space) {
  now_.space = space;
}
CREATURE_EXPORT void Creature::set_view_dis(const int32_t& d) {
  ability_.view_dis = std::min(kMaxViewDis, d);
  const size_t view_size = ((ability_.view_dis << 1) | 1);
  information_.is_viewable.resize(view_size);
  for (size_t i = 0; i < view_size; ++i) {
    information_.is_viewable[i].resize(view_size);
  }
}
CREATURE_EXPORT int32_t Creature::view_dis() const {return ability_.view_dis;}
CREATURE_EXPORT void Creature::UpdateViewable() {
  const size_t dis_array_size = information_.is_viewable.size();
  for (size_t i = 0; i < dis_array_size; ++i) {
    for (size_t j = 0; j < dis_array_size; ++j) {
      information_.is_viewable[i][j] = false;
    }
  }
  shadow_casting({now_position().x, now_position().y}, view_dis());
  UpdateMemory();
}
CREATURE_EXPORT bool Creature::is_viewable(const Point& pos) const {
  if (0 > pos.x || pos.x >= now_.map->Width()
    || 0 > pos.y || pos.y >= now_.map->Height()) return false;

  const Point target = {pos.x - now_position().x + view_dis(),
                        pos.y - now_position().y + view_dis()};
  const int32_t viewable_size = information_.is_viewable.size();
  if (target.x >= viewable_size || target.y >= viewable_size ||
      target.x < 0 || target.y < 0) return false;
  return information_.is_viewable[target.x][target.y];
}
CREATURE_EXPORT int32_t Creature::id() {
  if (!information_.is_have_id) get_id();
  return information_.id;
}
CREATURE_EXPORT void Creature::set_max_energy(const int32_t& energy) {
  ability_.max_energy = energy;
  ability_.now_energy = std::min(ability_.now_energy, ability_.max_energy);
}
CREATURE_EXPORT void Creature::set_now_energy(const int32_t& energy) {
  ability_.now_energy = std::min(energy, ability_.max_energy);
}
CREATURE_EXPORT void Creature::UpdateBlockTypeSize(size_t size) {
  information_.cost.resize(size);
}
CREATURE_EXPORT void Creature::set_cost(const Map::BlockType& type,
                                        const CostOfBlock_ref& cost) {
  information_.cost[type] = cost;
}
CREATURE_EXPORT Creature::~Creature() {}
CREATURE_EXPORT Space::MemoryOfMap& Creature::GetMemory() {
  return now_.space->GetMemory(id(), now_map());
}
CREATURE_NO_EXPORT Creature::Creature() {information_.is_have_id = false;}
CREATURE_NO_EXPORT Creature::Creature(Space* const space) {
  now_.space = space;
  information_.is_have_id = false;
}
CREATURE_NO_EXPORT void Creature::get_id() {information_.id = kCreatureSize++;}
CREATURE_NO_EXPORT void Creature::UpdateMemory() {
  Space::MemoryOfMap& now_mem = GetMemory();
  for (size_t i = 0; i < information_.is_viewable.size(); ++i) {
    for (size_t j = 0; j < information_.is_viewable.size(); ++j) {
      if (information_.is_viewable[i][j]) {
        const Point tmp = {now_position().x - view_dis() +
                           static_cast< int32_t >(i),
                           now_position().y - view_dis() +
                           static_cast< int32_t >(j)};
        now_mem.left_top.x = std::min(now_mem.left_top.x, tmp.x);
        now_mem.left_top.y = std::min(now_mem.left_top.y, tmp.y);
        now_mem.right_bottom.x = std::max(now_mem.right_bottom.x, tmp.x);
        now_mem.right_bottom.y = std::max(now_mem.right_bottom.y, tmp.y);
        now_mem.is_seen[tmp.x][tmp.y] = true;
        now_mem.detail->SetBlock(tmp, now_map()->Block(tmp));
      }
    }
  }
}

CREATURE_NO_EXPORT bool Creature::is_valid(const Point& pos) {
  const Point target = {pos.x - now_position().x + view_dis(),
                        pos.y - now_position().y + view_dis()};
  const int32_t viewable_size = information_.is_viewable.size();
  return 0 <= target.x && target.x < viewable_size
      && 0 <= target.y && target.y < viewable_size;
}

CREATURE_NO_EXPORT void Creature::set_viewable(const Point& pos) {
  if (is_valid(pos)) {
    information_.is_viewable[pos.x - now_position().x + view_dis()]
      [pos.y - now_position().y + view_dis()] = true;
  }
}

CREATURE_NO_EXPORT int32_t Creature::get_cost(const Point& pos) {
  return 0 <= pos.x && pos.x < now_.map->Width()
      && 0 <= pos.y && pos.y < now_.map->Height()
        ? information_.cost[now_map()->Block({pos.x, pos.y})
        ]->SeeThroughCost() : 0x3f3f3f3f;
}
